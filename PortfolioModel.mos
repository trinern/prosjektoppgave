model PortfolioModel
uses "mmxprs"; 

options explterm, noimplicit;

parameters
	DataFile = 'PortfolioDataTest.txt'; !'PortfolioData.txt' or 'PortfolioDataTest.txt'
	LoadFile = 'LoadDataTest.txt';!'LoadData.txt' or 'LoadDataTest.txt'
	IDPriceFile = 'IntraDayPriceFileTest.txt';	!IntraDayPriceFactor
	ForecastFile = 'ForecastDataTest.txt'; !'ForecastData.txt' or 'ForecastDataTest.txt' test: 48 h x 2
	ErrorFile = 'ForecastErrorDataTest.txt';
	DAPriceFile = 'DAPriceDataTest.txt';
	InFlowFile = 'InFlowTest.txt';
	original = true;
	SOSimplementation = false;	
	Presolve = true;
	Heuristic = true;
	Cutting = 'Yes';
	Print = 'True';
end-parameters

declarations
  timetracker:	real; ! used to log timestamps for time consumption output
end-declarations

writeln("Building model...");
timetracker := timestamp; ! assigns current "timestamp" to timetracker

!Declarations of sets
declarations
	nYears:			integer;
	nNodes:			integer;
	nHours:			integer;
	nPlants:		integer;	
	nScenarios:		integer;
	nErrors:		integer;
end-declarations
	
initializations from DataFile
	nYears;
	nNodes;
	nHours;
	nPlants;	
	nScenarios;
	nErrors;
end-initializations
	
declarations
	Years:			set of integer;	!Years in planning horizon
	Days:			set of integer;	!Days where decitions are made (1,2,3) ?(2 3 4 )
	DaysFC:			set of integer; !Days where a 24-forecast is given (1,2,3,4) ?(1 2 3 4)
	Nodes:			set of integer; !Set of nodes in tree
	Hours:			set of integer; !hours in each year in horizon
	Hours0:			set of integer;	!all first hours in each period
	HoursEnd:		set of integer; !all final hours in each period
	HoursD1:		set of integer;
	HoursD2:		set of integer;
	HoursD3:		set of integer;
	Plants:			set of integer;	!all identified power production plants
	Scenarios:		set of integer;	!first level uncertainty, given as paths until leaf nodes
	Errors:			set of integer;	!2nd level uncertainty
	CapPlants:		set of integer;	!power production projects with reliable capacity 
	WindPlants:		set of integer;	!wind plants
	ThermalPlants:	set of integer;	!set of thermal plants
	HydroPlants:	set of integer; !consider removing
end-declarations	

initializations from DataFile
	Days;
	DaysFC;
	Hours0;
	HoursEnd;
	HoursD1;
	HoursD2;
	HoursD3;
	CapPlants;
	WindPlants;
	ThermalPlants;
	HydroPlants;
end-initializations

Years		:= 1 .. nYears;	!t
Nodes		:= 1 .. nNodes;	!n
Hours		:= 1 .. nHours;		!h
Plants 		:= 1 .. nPlants;	!i
Scenarios 	:= 1 .. nScenarios;	!s
Errors		:= 1 .. nErrors;	!w

finalize(Years);
finalize(Nodes);
finalize(Hours);
!finalize(Hours0);
!finalize(HoursEnd);
finalize(Plants);
finalize(Scenarios);
finalize(Errors);
!finalize(CapPlants);
!finalize(ThermalPlants);

!Declarations of parameters in matrix form	
declarations
	DiscFactor:		array(Years)				of real;	!factor corresponding to discount rate
	Demand:			array(Hours)				of real;	!forcasted demand in hour h
	InvCost:		array(Plants)				of integer;
	!InvCostFixed:	array(Plants)				of integer;
	OprCost:		array(Plants)				of real;
	FixedOprCost:	array(Plants)				of integer;	!yearly operating cost
	UpperCap:		array(Plants)				of integer; !upper limit on cap installation
	StartUpCost:	array(ThermalPlants)		of integer;
	UpperRamping:	array(ThermalPlants)		of real;	!max ramping from h to h+1 thermal plants
	LowerThermal:	array(ThermalPlants)		of real;	!lower running capacity for thermal plants
	ProbS:			array(Scenarios)			of real;	!probability for scenario s
	ProbE:			array(Errors)				of real;	!probability for error w
	IDPriceFactor:	array(Hours)				of	real;	!load specific intra-day price
	!BalPurchPrice:	array(Scenarios, Errors)	of	real;!consider including demand
	ForecastError:	array(Hours, Scenarios, Errors)		of real;
	DayAheadPrice:	array(Hours)				of real;
	EstimatedProd:	array(Hours, Scenarios)		of real;!wind power production in scenario s, hour h
	OprHours:		array(Plants)				of real;
	ReservoirEnergy:array(HydroPlants, HoursEnd)		of integer;	!energy in reservoir at beginning of period (and end)
	InFlow:			array(HydroPlants, Hours)	of real;
end-declarations
	
initializations from DataFile
	DiscFactor;
	InvCost;
	!InvCostFixed;
	OprCost;
	FixedOprCost;
	UpperCap;
	StartUpCost;
	UpperRamping;
	LowerThermal;
	!BalPurchPrice;
	OprHours;
	ReservoirEnergy;
end-initializations

initializations from LoadFile
	Demand;
end-initializations

initializations from IDPriceFile
	IDPriceFactor;
end-initializations

initializations from ForecastFile
	ProbS;
	EstimatedProd;
end-initializations

initializations from ErrorFile
	ProbE;
	ForecastError;
end-initializations

initializations from DAPriceFile
	DayAheadPrice;
end-initializations

initializations from InFlowFile
	InFlow;
end-initializations


!Constants
declarations
	CapPrice:			real;
	Penalty:			integer;
	IDPriceConst:		real;	!wind power production const in price expression
	TransCostDayAhead:	real;	!proportional transaction cost day-ahead market
	TransCostIntraDay:	real;	!proportional transaction cost balance market, assumed equal for sales and purchases
	DayAheadFee:		integer;!yearly participation fee day-ahead market
	IntraDayFee:		integer;!yearly participation fee balance market
	LowerStressLimit:	real;	!definition for system stress at scenario s in hour h	
	PumpEff:			real;!efficiency of pump storage
	ScaleFactor:		integer;
	TotalWindCap:		integer;	!total installed wind power capacity in market
	ScenariosDay1:		integer; !Number of scenarios day one (second stage)
end-declarations
	
initializations from DataFile
	CapPrice;
	Penalty;
	IDPriceConst;
	TransCostDayAhead;
	TransCostIntraDay;
	DayAheadFee;
	IntraDayFee;
	LowerStressLimit;
	PumpEff;
	ScaleFactor;
	TotalWindCap;
	ScenariosDay1;
end-initializations

!Variables
declarations	

	investedCap: 			dynamic array (Plants, Scenarios) of mpvar;	!cap invested in plant i
	investedCapAnt:			dynamic array (Plants) of mpvar; !Non-anticipativity helping variable
	chosenPlant: 			dynamic array (Plants, Scenarios) of mpvar;	!binary var = 1 if plant i is chosen for investment
	chosenPlantAnt: 			dynamic array(Plants) of mpvar; !Non-anticipativity helping variable
	!dayAheadParticipation: 	dynamic array (Years, Scenarios) of mpvar;!binary var = 1 if day-ahead market participation in year t
	!intraDayParticipation: 	dynamic array (Years, Scenarios) of mpvar;!binary var = 1 if balance market participation in year t
	soldCap: 				dynamic array (Years, CapPlants, Scenarios) of mpvar;	!cap sold in cap market from plant i in year t
	soldCapAnt:				dynamic array (Years, CapPlants) of mpvar;	

	soldDayAhead: 			dynamic array(Years, Days, Hours, Scenarios) of mpvar;	!energy sold in day-ahead market for year t, hour h and 2nd stage scenario s
	soldDayAheadAnt: 		dynamic array(Years, Nodes, Hours) of mpvar;

	production: 	dynamic array (Years, Days, Hours, Plants, Scenarios, Errors) of mpvar;	!energy produced from plant i
	soldIntraDay: 	dynamic array (Years, Days, Hours, Scenarios, Errors) of mpvar;	!energy sold in intra-day market
	purchIntraDay:	dynamic array (Years, Days, Hours, Scenarios, Errors) of mpvar;	!energy purchased in intra-day market
	unmetCap: 		dynamic array (Years, Days, Hours, Plants, Scenarios, Errors) of mpvar;	!energy not meeting capacity liabilities. Assuming system stress lasting 1 h
	pumpStorage:	dynamic array (Years, Days, Hours, HydroPlants, Scenarios, Errors) of mpvar;
	isRunning:		dynamic array(Years, Days, Hours, ThermalPlants, Scenarios, Errors) of mpvar;
	startedAt:		dynamic array(Years, Days, Hours, ThermalPlants, Scenarios, Errors) of mpvar;
	stored:			dynamic array(Years, Days, Hours, HydroPlants, Scenarios, Errors) of mpvar; !Energy stored in reservoir at end of hour h
	spilled:		dynamic array(Years, Days, Hours, HydroPlants, Scenarios, Errors) of mpvar;		
end-declarations

forall (ii in Plants, ss in Scenarios) do
	create (investedCap(ii,ss));
	create (chosenPlant(ii,ss));
	chosenPlant(ii,ss) is_binary;
end-do

forall (ii in Plants) do
	create (investedCapAnt(ii));
	create (chosenPlantAnt(ii));
	chosenPlantAnt(ii) is_binary;
end-do

(!forall (tt in Years) do
	create (dayAheadParticipation(tt));
	dayAheadParticipation(tt) is_binary;
	create (intraDayParticipation(tt));
	intraDayParticipation(tt) is_binary;
end-do!)

forall (tt in Years, ii in CapPlants, ss in Scenarios) do
	create (soldCap(tt, ii,ss));
end-do

forall (tt in Years, ii in CapPlants) do
	create (soldCapAnt(tt, ii));
end-do

forall (tt in Years, hh in HoursD1, ss in Scenarios) do !consider preprocessing
	create (soldDayAhead(tt, 1 ,hh, ss));
end-do
forall (tt in Years, hh in HoursD2, ss in Scenarios) do !consider preprocessing
	create (soldDayAhead(tt, 2 ,hh, ss));
end-do
forall (tt in Years, hh in HoursD3, ss in Scenarios) do !consider preprocessing
	create (soldDayAhead(tt,3 ,hh, ss));
end-do

!fiks korrespondanse dager, timer
forall (tt in Years,nn in Nodes, hh in Hours) do 
	create (soldDayAheadAnt(tt,nn,hh));
end-do

forall (tt in Years, hh in HoursD1, ii in Plants, ss in Scenarios, ww in Errors) do !consider preprocessing
	create (production(tt, 1, hh, ii, ss, ww));
end-do
forall (tt in Years, hh in HoursD2, ii in Plants, ss in Scenarios, ww in Errors) do !consider preprocessing
	create (production(tt, 2, hh, ii, ss, ww));
end-do
forall (tt in Years, hh in HoursD3, ii in Plants, ss in Scenarios, ww in Errors) do !consider preprocessing
	create (production(tt,3, hh, ii, ss, ww));
end-do

forall (tt in Years, hh in HoursD1, ss in Scenarios, ww in Errors) do !consider preprocessing
	create (soldIntraDay(tt,1, hh, ss, ww));
	create (purchIntraDay(tt,1, hh, ss, ww));
end-do
forall (tt in Years, hh in HoursD2, ss in Scenarios, ww in Errors) do !consider preprocessing
	create (soldIntraDay(tt,2, hh, ss, ww));
	create (purchIntraDay(tt,2, hh, ss, ww));
end-do
forall (tt in Years, hh in HoursD3, ss in Scenarios, ww in Errors) do !consider preprocessing
	create (soldIntraDay(tt,3, hh, ss, ww));
	create (purchIntraDay(tt,3, hh, ss, ww));
end-do


forall (tt in Years, hh in HoursD1, ii in ThermalPlants, ss in Scenarios, ww in Errors) do
	create (startedAt(tt,1, hh, ii, ss, ww));
	startedAt(tt,1,hh,ii,ss,ww) is_binary;
	create (isRunning(tt,1, hh, ii, ss, ww));
	isRunning(tt,1,hh,ii,ss,ww) is_binary;
end-do
forall (tt in Years, hh in HoursD2, ii in ThermalPlants, ss in Scenarios, ww in Errors) do
	create (startedAt(tt,2, hh, ii, ss, ww));
	startedAt(tt,2,hh,ii,ss,ww) is_binary;
	create (isRunning(tt,2, hh, ii, ss, ww));
	isRunning(tt,2,hh,ii,ss,ww) is_binary;
end-do
forall (tt in Years, hh in HoursD3, ii in ThermalPlants, ss in Scenarios, ww in Errors) do
	create (startedAt(tt,3, hh, ii, ss, ww));
	startedAt(tt,3,hh,ii,ss,ww) is_binary;
	create (isRunning(tt,3, hh, ii, ss, ww));
	isRunning(tt,3,hh,ii,ss,ww) is_binary;
end-do

forall (tt in Years, hh in HoursD1, ii in HydroPlants, ss in Scenarios, ww in Errors) do
	create (pumpStorage(tt,1,hh, ii, ss, ww));
end-do
forall (tt in Years, hh in HoursD2, ii in HydroPlants, ss in Scenarios, ww in Errors) do
	create (pumpStorage(tt,2,hh, ii, ss, ww));
end-do
forall (tt in Years, hh in HoursD3, ii in HydroPlants, ss in Scenarios, ww in Errors) do
	create (pumpStorage(tt,3,hh, ii, ss, ww));
end-do

forall (tt in Years, hh in HoursD1, ii in CapPlants, ss in Scenarios, ww in Errors) do !consider preprocessing
	create (unmetCap(tt,1, hh, ii, ss, ww));
end-do
forall (tt in Years, hh in HoursD2, ii in CapPlants, ss in Scenarios, ww in Errors) do !consider preprocessing
	create (unmetCap(tt,2, hh, ii, ss, ww));
end-do
forall (tt in Years, hh in HoursD3, ii in CapPlants, ss in Scenarios, ww in Errors) do !consider preprocessing
	create (unmetCap(tt,3, hh, ii, ss, ww));
end-do

forall (tt in Years, hh in HoursD1, ii in HydroPlants, ss in Scenarios, ww in Errors) do
	create(stored(tt,1,hh,ii,ss,ww));
	create(spilled(tt,1,hh,ii,ss,ww));
end-do
forall (tt in Years, hh in HoursD2, ii in HydroPlants, ss in Scenarios, ww in Errors) do
	create(stored(tt,2,hh,ii,ss,ww));
	create(spilled(tt,2,hh,ii,ss,ww));
end-do
forall (tt in Years, hh in HoursD3, ii in HydroPlants, ss in Scenarios, ww in Errors) do
	create(stored(tt,3,hh,ii,ss,ww));
	create(spilled(tt,3,hh,ii,ss,ww));
end-do

!Constraints
declarations
	NetPresentValue:	linctr;!obj value
	CapacityCon:		dynamic array (Years, CapPlants, Scenarios) of linctr;!available reliable capacity for sales in cap market
	ProductionConWind:	dynamic array (Years, Days,Hours, WindPlants, Scenarios, Errors) of linctr;!upper bound energy production form wind plants
	ProductionConStable:dynamic array (Years, Days, Hours, Plants, Scenarios, Errors) of linctr;!upper bound energy production. Except hydro?
	ProductionThermal:	dynamic array (Years, Days, Hours, ThermalPlants, Scenarios, Errors) of linctr;
	StartingCon:		dynamic array (Years, Days, Hours, ThermalPlants, Scenarios, Errors) of linctr;
	RampingCon:			dynamic array (Years, Days, Hours, ThermalPlants, Scenarios, Errors) of linctr;
	HydroCon:			dynamic array (Years, Days, Hours, HydroPlants, Scenarios, Errors) of linctr;!hydropower constraint
	HydroConEnd:		dynamic array (Years, Days, HoursEnd,HydroPlants,Scenarios,Errors) of linctr;
	InvestmentCon:		dynamic array (Plants, Scenarios) of linctr;
	ProdSalesBalance:	dynamic array (Years, Days, Hours, Scenarios, Errors) of linctr;	!balancing production, sales, purchases, pumping
	StressBalance:		dynamic array (Years, Days, Hours, CapPlants, Scenarios, Errors) of linctr;!balancing production, sales and unmet cap liabilities during system stress
	LowLimThermal:		dynamic array (Years, Days, Hours, ThermalPlants, Scenarios, Errors) of linctr; ! lower limit production thermal plants
	IDMarketPart1:		dynamic array (Years) of linctr;	!controlling variable for balance market participation against purchase variable
	IDMarketPart2:		dynamic array (Years) of linctr;	!controlling variable for balance market participation against sale variable
	DayAheadMarketPart:	dynamic array (Years) of linctr;	!controlling variable for Day-ahead market participation
	Anticipativity1:	dynamic array(Plants, Scenarios) of linctr;
	Anticipativity2:	dynamic array(Plants, Scenarios) of linctr;
	Anticipativity3:	dynamic array(Years, Plants, Scenarios) of linctr;
	Anticipativity4:	dynamic array(Years, Nodes, DaysFC, Hours, Scenarios) of linctr;
end-declarations

NetPresentValue :=
	sum (ss in Scenarios)ProbS(ss)*(
		-
		sum (ii in Plants) InvCost(ii)*investedCap(ii,ss)
		-
		!sum (tt in Years) DiscFactor(tt)*(DayAheadFee*dayAheadParticipation(tt) + BalanceFee*balanceParticipation(tt))
		+
		sum (tt in Years, ii in CapPlants) DiscFactor(tt)*(CapPrice*soldCap(tt,ii,ss) - FixedOprCost(ii)*chosenPlant(ii,ss))
		+ 
		sum (tt in Years, dd in Days, hh in Hours) DiscFactor(tt)*ScaleFactor*soldDayAhead(tt,dd,hh,ss)*(DayAheadPrice(hh)-TransCostDayAhead)
		+
		sum (tt in Years, dd in Days, hh in Hours, ww in Errors) ProbE(ww)*
		(
			soldIntraDay(tt,dd,hh,ss,ww)*(IDPriceFactor(hh)*Demand(hh)+IDPriceConst-TransCostIntraDay) 
			- purchIntraDay(tt,dd,hh,ss,ww)*(IDPriceFactor(hh)*Demand(hh)+IDPriceConst-TransCostIntraDay) 
			- sum (ii in Plants)OprCost(ii)*production(tt,dd,hh,ii,ss,ww)
			- sum (ii in ThermalPlants) StartUpCost(ii)*startedAt(tt,dd,hh,ii,ss,ww)
			- sum (ii in CapPlants) Penalty*unmetCap(tt,dd,hh,ii,ss,ww)
		)
	);
				
forall(tt in Years, ii in CapPlants, ss in Scenarios) do
	CapacityCon(tt,ii,ss):=
		soldCap(tt,ii,ss) - investedCap(ii,ss) <= 0;	!capacity sold from plant i in CM in year t cant be more than max capacity at cap plant i
end-do

forall(tt in Years, dd in Days, hh in Hours, ii in WindPlants, ss in Scenarios, ww in Errors) do
	ProductionConWind(tt,dd,hh,ii,ss,ww):=
		production(tt,dd, hh,ii,ss,ww) - (EstimatedProd(hh,ss)+ ForecastError(hh,ss,ww))*OprHours(ii)*investedCap(ii,ss) = 0;	!Upper bound intermittent production, scenario dependent
end-do

forall(tt in Years, dd in Days, hh in Hours, ii in Plants | Plants <> WindPlants, ss in Scenarios, ww in Errors) do
	ProductionConStable(tt,dd,hh,ii,ss,ww):=
		production(tt,dd,hh,ii,ss,ww) - OprHours(ii)*investedCap(ii,ss) <= 0;	!Upper bound stable production
end-do

forall (tt in Years, dd in Days, hh in Hours, ii in ThermalPlants, ss in Scenarios, ww in Errors) do
	ProductionThermal(tt,dd,hh,ii,ss,ww):=
		production(tt,dd,hh,ii,ss,ww) - UpperCap(ii)*isRunning(tt,dd,hh,ii,ss,ww) <= 0;
end-do

forall (tt in Years, dd in Days, hh in Hours | (hh not in Hours0), ii in ThermalPlants, ss in Scenarios, ww in Errors) do
	StartingCon(tt,dd,hh,ii,ss,ww):=
		isRunning(tt,dd,(hh-1),ii,ss,ww) + startedAt(tt,dd,hh,ii,ss,ww) - isRunning(tt,dd,hh,ii,ss,ww) = 0;
end-do

forall (tt in Years, dd in Days, hh in Hours0, ii in ThermalPlants, ss in Scenarios, ww in Errors) do
	StartingCon(tt,dd,hh,ii,ss,ww):=
		startedAt(tt,dd,hh,ii,ss,ww) - isRunning(tt,dd,hh,ii,ss,ww) = 0;
end-do

forall(tt in Years, dd in Days, hh in Hours | hh not in Hours0, ii in ThermalPlants, ss in Scenarios, ww in Errors) do
	RampingCon(tt,dd,hh,ii,ss,ww):=
		production(tt,dd,hh,ii,ss,ww) - production(tt,dd,(hh-1),ii,ss,ww) - UpperRamping(ii)*(investedCap(ii,ss)) <= 0;	!max ramping when production is increasing from h to h+1 when, given as share of max capacity
end-do

forall(tt in Years,dd in Days, hh in Hours0, ii in ThermalPlants, ss in Scenarios, ww in Errors) do
	RampingCon(tt,dd,hh,ii,ss,ww):=
		production(tt,dd,hh,ii,ss,ww) - UpperRamping(ii)*investedCap(ii,ss) <= 0;	!ramping constraint first hour in period
end-do

forall(tt in Years, dd in Days, hh in Hours | hh not in Hours0 , ii in HydroPlants, ss in Scenarios, ww in Errors) do
	HydroCon(tt,dd,hh,ii,ss,ww):=
		stored(tt,dd,hh,ii,ss,ww)-stored(tt,dd,(hh-1),ii,ss,ww) - PumpEff*pumpStorage(tt,dd,hh,ii,ss,ww) + production(tt,dd,hh,ii,ss,ww) + spilled(tt,dd,hh,ii,ss,ww) = InFlow(ii,hh);
end-do
		
forall(tt in Years, dd in Days, hh in Hours0, ii in HydroPlants, ss in Scenarios, ww in Errors) do
	HydroCon(tt,dd,hh,ii,ss,ww):=
		stored(tt,dd,hh,ii,ss,ww) - PumpEff*pumpStorage(tt,dd,hh,ii,ss,ww) + production(tt,dd,hh,ii,ss,ww) + spilled(tt,dd,hh,ii,ss,ww) = ReservoirEnergy(ii,hh) + InFlow(ii,hh);!ResEnergy(ii,hh) or (ii)?
end-do

forall(tt in Years, dd in Days, hh in HoursEnd, ii in HydroPlants, ss in Scenarios, ww in Errors) do
	HydroConEnd(tt,dd,hh,ii,ss,ww):=
		stored(tt,dd,hh,ii,ss,ww)  = ReservoirEnergy(ii,hh);
end-do

forall(ii in Plants, ss in Scenarios) do
	InvestmentCon(ii,ss):=
		investedCap(ii,ss) - UpperCap(ii)*chosenPlant(ii,ss) <= 0;
end-do

forall(tt in Years, dd in Days, hh in Hours, ss in Scenarios, ww in Errors) do
	ProdSalesBalance(tt,dd,hh,ss,ww):=												!Balance for energy produced, stored, sold and purchased
		+ purchIntraDay(tt,dd,hh,ss,ww)- soldIntraDay(tt,dd,hh,ss,ww)
		- soldDayAhead(tt,dd,hh,ss)
		- sum(ii in HydroPlants) stored(tt,dd,hh,ii,ss,ww)
		+ sum(ii in Plants)production(tt,dd,hh,ii,ss,ww)
		= 0;	
end-do		
				
forall (tt in Years,dd in Days, hh in Hours, ii in CapPlants, ss in Scenarios | (Demand(hh)-TotalWindCap*EstimatedProd(hh,ss)) > LowerStressLimit, ww in Errors) do !test for system stress, can use another value for wind power prod
	StressBalance(tt,dd,hh,ii,ss,ww):=
		production(tt,dd,hh,ii,ss,ww) + unmetCap(tt,dd,hh,ii,ss,ww) - soldCap(tt,ii,ss) = 0; ! if sold cap from i must be met by production on plant i
end-do

(!
forall (tt in Years, hh in Hours, ss in Scenarios | (Demand(hh)-EstimatedProd(ss,hh)) > LowerStressLimit, ww in Errors) do !test for system stress, can use another value for wind power prod
	StressBalance(tt,hh,ss,ww):=
		sum (ii in Plants) production(tt,hh,ii,ss,ww) + unmetCap(tt,hh,ss,ww) - sum(jj in CapPlants)soldCap(tt,jj) = 0;	!if sold cap from plant i can be met by production on any plant
end-do
!)

forall(tt in Years, dd in Days, hh in Hours, ii in ThermalPlants, ss in Scenarios, ww in Errors) do
	LowLimThermal(tt,dd,hh,ii,ss,ww):=
		production(tt,dd,hh,ii,ss,ww) >= LowerThermal(ii)*OprHours(ii);
end-do

forall(tt in Years) do
	IDMarketPart1(tt):=	!controlling the variable for participation in Bal market to be 1 if any purchase variable is > 0
		sum(hh in Hours, dd in Days, ss in Scenarios, ww in Errors) purchIntraDay(tt,dd,hh,ss,ww) 
		- 
		sum(ii in Plants) UpperCap(ii)*nHours*nScenarios*nErrors 
		<= 0;	
	IDMarketPart2(tt):=	!controlling the variable for participation in Bal market to be 1 if any sale variable is > 0
		sum(hh in Hours, dd in Days, ss in Scenarios, ww in Errors) soldIntraDay(tt,dd,hh,ss,ww) 
		- 
		sum(ii in Plants) UpperCap(ii)*nHours*nScenarios*nErrors 
		<= 0;
	DayAheadMarketPart(tt):=	!controlling the variable for participation in Day ahead market to be 1 if any sale variable is > 0
		sum(dd in Days, hh in Hours, ss in Scenarios) soldDayAhead(tt,dd,hh,ss) 
		- 
		sum(ii in Plants) UpperCap(ii)*nHours*nScenarios 
		<= 0;		
end-do		

!Non-anticipativity constraints

forall(ii in Plants, ss in Scenarios) do
	Anticipativity1(ii,ss):=
	 	investedCap(ii,ss) = investedCapAnt(ii);
end-do

forall(ii in Plants, ss in Scenarios) do
	Anticipativity2(ii,ss):=
	 	chosenPlant(ii,ss) = chosenPlantAnt(ii);
end-do

forall(tt in Years, ii in CapPlants, ss in Scenarios) do
	Anticipativity3(tt,ii,ss):=
	 	soldCap(tt,ii,ss) = soldCapAnt(tt,ii);
end-do

!!Kommet hit
!Veldig usikker på dette fungerer.... Hvilke scenarioer restriksjonen gjelder for må være gitt av n. Det kan være lettere å hardcode det direkte når vi vet hvor mange scenarioer som er knyttet til hver node. 
!antall noder in Nodes er noder som har day-ahead beslutninger 
forall(tt in Years, hh in Hours, ss in Scenarios) do
	Anticipativity4(tt,1,1,hh,ss):=
	 	soldDayAhead(tt,1,hh,ss) = soldDayAheadAnt(tt,1,hh);
end-do

forall(tt in Years, nn in Nodes|(nn>1 & nn<=(ScenariosDay1+1)),  hh in Hours, ss in Scenarios | (ss > (nn-1)*(nScenarios/ScenariosDay1) && ss <= (nn)*(nScenarios/ScenariosDay1))) do
	Anticipativity4(tt,nn,2,hh,ss):=
	 	soldDayAhead(tt,2,hh,ss) = soldDayAheadAnt(tt,nn,hh);
end-do

forall(tt in Years,nn in Nodes|(nn>(ScenariosDay1+1)&& nn<=(ScenariosDay1+ScenariosDay1^2)+1),hh in Hours,ss in Scenarios|(Scenarios >(nn-1)*((nScearios/ScenariosDay1)/ScenariosDay1) && Scenarios <= (nn)*((nScearios/ScenariosDay1)/ScenariosDay1))) do
	Anticipativity4(nn,tt,3,hh,ss):=
	 	soldDayAhead(tt,3,hh,ss) = soldDayAheadAnt(nn,tt,hh);
end-do


writeln("\nModel building completed in ", timestamp - timetracker, " seconds");
writeln("\nSolving model...");
timetracker := timestamp;
		
maximize(NetPresentValue);

writeln("\nModel solved in ", timestamp - timetracker," seconds");

end-model

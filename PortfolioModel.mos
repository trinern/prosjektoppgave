model PortfolioModel
uses "mmxprs"; 

options explterm, noimplicit;

parameters
	DataFile = 'PortfolioDataTest.txt'; !Test files when running on student license
	LoadFile = 'LoadDataTest.txt';!Test files when running on student license
	original = true;
	SOSimplementation = false;	
	Presolve = true;
	Heuristic = true;
	Cutting = 'Yes';
	Print = 'True';
end-parameters

declarations
  timetracker:	real; ! used to log timestamps for time consumption output
end-declarations

writeln("Building model...");
timetracker := timestamp; ! assigns current "timestamp" to timetracker

!Declarations of sets
declarations
	nYears:			integer;
	nHours:			integer;
	nPlants:		integer;	
	nScenarios:		integer;
	nErrors:		integer;
end-declarations
	
initializations from DataFile
	nYears;
	nHours;
	nPlants;	
	nScenarios;
	nErrors;
end-initializations
	
declarations
	Years:			set of integer;	!Years in planning horizon
	Hours:			set of integer; !hours in each year in horizon
	Hours0:			set of integer;	!all first hours in each period
	Plants:			set of integer;	!all identified power production plants
	Scenarios:		set of integer;	!2nd stage uncertainty
	Errors:			set of integer;	!3rd stage uncertainty
	CapPlants:		set of integer;	!power production projects with reliable capacity 
	WindPlants:		set of integer;	!wind plants
	ThermalPlants:	set of integer;	!set of thermal plants
	HydroPlants:	set of integer; !consider removing
end-declarations	

initializations from DataFile
	Hours0;
	CapPlants;
	WindPlants;
	ThermalPlants;
	HydroPlants;
end-initializations

Years		:= 1 .. nYears;	!t
Hours		:= 1 .. nHours;		!h
Plants 		:= 1 .. nPlants;	!i
Scenarios 	:= 1 .. nScenarios;	!s
Errors		:= 1 .. nErrors;	!w

finalize(Years);
finalize(Hours);
finalize(Hours0);
finalize(Plants);
finalize(Scenarios);
finalize(Errors);
finalize(CapPlants);
finalize(ThermalPlants);

!Declarations of parameters in matrix form	
declarations
	DiscFactor:		array(Years)				of real;	!factor corresponding to discount rate
	Demand:			array(Hours)				of real;	!forcasted demand in hour h
	InvCost:		array(Plants)				of integer;
	InvCostFixed:	array(Plants)				of integer;
	OprCost:		array(Plants)				of integer;
	UpperCap:		array(Plants)				of integer; !upper limit on cap installation
	StartUpCost:	array(ThermalPlants)		of integer;
	UpperRamping:	array(ThermalPlants)		of real;	!max ramping from h to h+1 thermal plants
	LowerThermal:	array(ThermalPlants)		of real;	!lower running capacity for thermal plants
	Prob2:			array(Scenarios)			of real;	!probability for scenario s
	Prob3:			array(Scenarios, Errors)	of real;	!probability for error w given scenario s
	BalSalesPrice:	array(Scenarios, Errors)	of	real;!consider including demand
	BalPurchPrice:	array(Scenarios, Errors)	of	real;!consider including demand
	ForecastError:	array(Scenarios, Errors)	of real;
	DayAheadPrice:	array(Scenarios, Hours)		of real;!Include demand?
	EstimatedProd:	array(Scenarios, Hours)		of real;!wind power production in scenario s, hour h
	OprHours:		array(Plants)				of real;
	ReservoirEnergy:array(Plants, Hours0)		of integer;	!energy in reservoir at beginning of period
end-declarations
	
initializations from DataFile
	DiscFactor;
	InvCost;
	InvCostFixed;
	OprCost;
	UpperCap;
	StartUpCost;
	UpperRamping;
	LowerThermal;
	Prob2;
	Prob3;
	BalSalesPrice;
	BalPurchPrice;
	ForecastError;
	DayAheadPrice;
	EstimatedProd;
	OprHours;
	ReservoirEnergy;
end-initializations

initializations from LoadFile
	Demand;
end-initializations

!Constants
declarations
	CapPrice:			integer;
	Penalty:			integer;
	TransCostDayAhead:	real;	!proportional transaction cost day-ahead market
	TransCostBalance:	real;	!proportional transaction cost balance market, assumed equal for sales and purchases
	DayAheadFee:		integer;!yearly participation fee day-ahead market
	BalanceFee:			integer;!yearly participation fee balance market
	LowerStressLimit:	real;	!definition for system stress at scenario s in hour h	
	PumpEff:			real;!efficiency of pump storage
	ScaleFactor:		integer;
end-declarations
	
initializations from DataFile
	CapPrice;
	Penalty;
	TransCostDayAhead;
	TransCostBalance;
	DayAheadFee;
	BalanceFee;
	LowerStressLimit;
	PumpEff;
	ScaleFactor;
end-initializations

!Variables
declarations	
	!1st stage
	investedCap: 			dynamic array (Plants) of mpvar;	!cap invested in plant i
	chosenPlant: 			dynamic array (Plants) of mpvar;	!binary var = 1 if plant i is chosen for investment
	dayAheadParticipation: 	dynamic array (Years) of mpvar;!binary var = 1 if day-ahead market participation in year t
	balanceParticipation: 	dynamic array (Years) of mpvar;!binary var = 1 if balance market participation in year t
	soldCap: 				dynamic array (Years, CapPlants) of mpvar;	!cap sold in cap market from plant i in year t
	!2nd stage
	soldDayAhead: dynamic array(Years, Hours, Scenarios) of mpvar;	!energy sold in day-ahead market for year t, hour h and 2nd stage scenario s
	!3rd stage
	production: dynamic array (Years, Hours, Plants, Scenarios, Errors) of mpvar;	!energy produced from plant i
	soldBalance: dynamic array (Years, Hours, Scenarios, Errors) of mpvar;	!energy sold in balance market
	purchBalance: dynamic array (Years, Hours, Scenarios, Errors) of mpvar;	!energy purchased in balance market
	unmetCap: dynamic array (Years, Hours, Plants, Scenarios, Errors) of mpvar;	!energy not meeting capacity liabilities. Assuming system stress lasting 1 h
	pumpStorage:	dynamic array (Years, Hours, HydroPlants, Scenarios, Errors) of mpvar;
	isRunning:		dynamic array(Years, Hours, ThermalPlants, Scenarios, Errors) of mpvar;
	startedAt:		dynamic array(Years, Hours, ThermalPlants, Scenarios, Errors) of mpvar;
end-declarations

forall (ii in Plants) do
	create (investedCap(ii));
	create (chosenPlant(ii));
	chosenPlant(ii) is_binary;
end-do

forall (tt in Years) do
	create (dayAheadParticipation(tt));
	dayAheadParticipation(tt) is_binary;
	create (balanceParticipation(tt));
	balanceParticipation(tt) is_binary;
end-do

forall (tt in Years, ii in CapPlants) do
	create (soldCap(tt, ii));
end-do

forall (tt in Years, hh in Hours, ss in Scenarios) do !consider preprocessing
	create (soldDayAhead(tt ,hh, ss));
end-do

forall (tt in Years, hh in Hours, ii in Plants, ss in Scenarios, ww in Errors) do !consider preprocessing
	create (production(tt, hh, ii, ss, ww));
end-do

forall (tt in Years, hh in Hours, ss in Scenarios, ww in Errors) do !consider preprocessing
	create (soldBalance(tt, hh, ss, ww));
	create (purchBalance(tt, hh, ss, ww));
end-do

forall (tt in Years, hh in Hours, ii in ThermalPlants, ss in Scenarios, ww in Errors) do
	create (startedAt(tt, hh, ii, ss, ww));
	startedAt(tt,hh,ii,ss,ww) is_binary;
	create (isRunning(tt, hh, ii, ss, ww));
	isRunning(tt,hh,ii,ss,ww) is_binary;
end-do

!Constraints
declarations
	NetPresentValue:	linctr;!obj value
	CapacityCon:		dynamic array (Years, CapPlants) of linctr;!available reliable capacity for sales in cap market
	ProductionConWind:	dynamic array (Years, Hours, WindPlants, Scenarios, Errors) of linctr;!upper bound energy production form wind plants
	ProductionConStable:dynamic array (Years, Hours, Plants, Scenarios, Errors) of linctr;!upper bound energy production. Except hydro?
	ProductionThermal:	dynamic array (Years, Hours, ThermalPlants, Scenarios, Errors) of linctr;
	StartingCon:		dynamic array (Years, Hours, ThermalPlants, Scenarios, Errors) of linctr;
	RampingCon:			dynamic array (Years, Hours, ThermalPlants, Scenarios, Errors) of linctr;
	HydroCon:			dynamic array (Years, Hours, HydroPlants, Scenarios, Errors, Hours0) of linctr;!hydropower constraint
	InvestmentCon:		dynamic array (Plants) of linctr;
	ProdSalesBalance:	dynamic array (Years, Hours, Scenarios, Errors) of linctr;	!balancing production, sales, purchases, pumping
	StressBalance:		dynamic array (Years, Hours, CapPlants, Scenarios, Errors) of linctr;!balancing production, sales and unmet cap liabilities during system stress
	LowLimThermal:		dynamic array (Years, Hours, ThermalPlants, Scenarios, Errors) of linctr; ! lower limit production thermal plants
	BalMarketPart1:		dynamic array (Years) of linctr;	!controlling variable for balance market participation against purchase variable
	BalMarketPart2:		dynamic array (Years) of linctr;	!controlling variable for balance market participation against sale variable
	DayAheadMarketPart:	dynamic array (Years) of linctr;	!controlling variable for Day-ahead market participation
end-declarations

NetPresentValue :=
		-
		sum (ii in Plants) (InvCost(ii)*investedCap(ii) + InvCostFixed(ii)*chosenPlant(ii))
		-
		sum (tt in Years) DiscFactor(tt)*(DayAheadFee*dayAheadParticipation(tt) + BalanceFee*balanceParticipation(tt))
		+
		sum (tt in Years, ii in CapPlants) DiscFactor(tt)*CapPrice*soldCap(tt, ii)
		+ 
		ScaleFactor * sum (tt in Years)DiscFactor(tt)*
			(
				sum (ss in Scenarios) Prob2(ss) *
					(
						sum (hh in Hours) (DayAheadPrice(ss, hh)-TransCostDayAhead)*soldDayAhead(tt,hh,ss)
						+
						sum(ww in Errors) Prob3(ss,ww)*
							(
								sum (hh in Hours, ii in Plants)
									(
										(BalSalesPrice(ss,ww)-TransCostBalance) * soldBalance(tt,hh,ss,ww)
										-
										(BalPurchPrice(ss,ww)+TransCostBalance) * purchBalance(tt,hh,ss,ww)
										-
										OprCost(ii)*production(tt,hh,ii,ss,ww)
										-
										Penalty*unmetCap(tt,hh,ii,ss,ww)
									)	
								-
								sum(hh in Hours, ii in ThermalPlants) StartUpCost(ii)*startedAt(tt,hh,ii,ss,ww)
		
							)
					)
			);
			
forall(tt in Years, ii in CapPlants) do
	CapacityCon(tt,ii):=
		soldCap(tt,ii) - investedCap(ii) <= 0;	!capacity sold from plant i in CM in year t cant be more than max capacity at cap plant i
end-do

forall(tt in Years, hh in Hours, ii in WindPlants, ss in Scenarios, ww in Errors) do
	ProductionConWind(tt,hh,ii,ss,ww):=
		production(tt,hh,ii,ss,ww) - EstimatedProd(ss,hh)*(1-ForecastError(ss,ww))*OprHours(ii)*investedCap(ii) = 0;	!Upper bound intermittent production, scenario dependent
end-do

forall(tt in Years, hh in Hours, ii in Plants | Plants <> WindPlants, ss in Scenarios, ww in Errors) do
	ProductionConStable(tt,hh,ii,ss,ww):=
		production(tt,hh,ii,ss,ww) - OprHours(ii)*investedCap(ii) <= 0;	!Upper bound stable production
end-do

forall (tt in Years, hh in Hours, ii in ThermalPlants, ss in Scenarios, ww in Errors) do
	ProductionThermal(tt,hh,ii,ss,ww):=
		production(tt,hh,ii,ss,ww) - UpperCap(ii)*isRunning(tt,hh,ii,ss,ww) <= 0;
end-do

forall (tt in Years, hh in Hours | (hh not in Hours0), ii in ThermalPlants, ss in Scenarios, ww in Errors) do
	StartingCon(tt,hh,ii,ss,ww):=
		isRunning(tt,(hh-1),ii,ss,ww) + startedAt(tt,hh,ii,ss,ww) - isRunning(tt,hh,ii,ss,ww) = 0;
end-do

forall (tt in Years, hh in Hours0, ii in ThermalPlants, ss in Scenarios, ww in Errors) do
	StartingCon(tt,hh,ii,ss,ww):=
		startedAt(tt,hh,ii,ss,ww) - isRunning(tt,hh,ii,ss,ww) = 0;
end-do

forall(tt in Years, hh in Hours | hh not in Hours0, ii in ThermalPlants, ss in Scenarios, ww in Errors) do
	RampingCon(tt,hh,ii,ss,ww):=
		production(tt,hh,ii,ss,ww) - production(tt,(hh-1),ii,ss,ww) - UpperRamping(ii)*(investedCap(ii)) <= 0;	!max ramping when production is increasing from h to h+1 when, given as share of max capacity
end-do

forall(tt in Years, hh in Hours0, ii in ThermalPlants, ss in Scenarios, ww in Errors) do
	RampingCon(tt,hh,ii,ss,ww):=
		production(tt,hh,ii,ss,ww) - UpperRamping(ii)*investedCap(ii) <= 0;	!ramping constraint first hour in period
end-do

forall(tt in Years, hh in Hours | hh not in Hours0 , ii in HydroPlants, ss in Scenarios, ww in Errors, kk in Hours0) do
	HydroCon(tt,hh,ii,ss,ww,kk):=
		production(tt,hh,ii,ss,ww) + sum(jj in 1..(hh-1))(production(tt,jj,ii,ss,ww) - PumpEff*pumpStorage(tt,jj,ii,ss,ww)) <= ReservoirEnergy(ii,kk);
end-do
		
forall(tt in Years, hh in Hours0, ii in HydroPlants, ss in Scenarios, ww in Errors, kk in Hours0) do
	HydroCon(tt,hh,ii,ss,ww,kk):=
		production(tt,hh,ii,ss,ww) <= ReservoirEnergy(ii,kk);
end-do

forall(ii in Plants) do
	InvestmentCon(ii):=
		investedCap(ii) - UpperCap(ii)*chosenPlant(ii) <= 0;
end-do

forall(tt in Years, hh in Hours, ss in Scenarios, ww in Errors) do
	ProdSalesBalance(tt,hh,ss,ww):=												!Balance for energy produced, stored, sold and purchased
		+ purchBalance(tt,hh,ss,ww)- soldBalance(tt,hh,ss,ww)
		- soldDayAhead(tt,hh,ss)
		- sum(ii in HydroPlants) pumpStorage(tt,hh,ii,ss,ww)
		+ sum(ii in Plants)production(tt,hh,ii,ss,ww)
		= 0;	
end-do
			
				
forall (tt in Years, hh in Hours, ii in CapPlants, ss in Scenarios | (Demand(hh)-EstimatedProd(ss,hh)) > LowerStressLimit, ww in Errors) do !test for system stress, can use another value for wind power prod
	StressBalance(tt,hh,ii,ss,ww):=
		production(tt,hh,ii,ss,ww) + unmetCap(tt,hh,ii,ss,ww) - soldCap(tt,ii) = 0; ! if sold cap from i must be met by production on plant i
end-do

(!
forall (tt in Years, hh in Hours, ss in Scenarios | (Demand(hh)-EstimatedProd(ss,hh)) > LowerStressLimit, ww in Errors) do !test for system stress, can use another value for wind power prod
	StressBalance(tt,hh,ss,ww):=
		sum (ii in Plants) production(tt,hh,ii,ss,ww) + unmetCap(tt,hh,ss,ww) - sum(jj in CapPlants)soldCap(tt,jj) = 0;	!if sold cap from plant i can be met by production on any plant
end-do
!)

forall(tt in Years, hh in Hours, ii in ThermalPlants, ss in Scenarios, ww in Errors) do
	LowLimThermal(tt,hh,ii,ss,ww):=
		production(tt,hh,ii,ss,ww) >= LowerThermal(ii)*OprHours(ii);
end-do

forall(tt in Years) do
	BalMarketPart1(tt):=	!controlling the variable for participation in Bal market to be 1 if any purchase variable is > 0
		sum(hh in Hours, ss in Scenarios, ww in Errors) purchBalance(tt,hh,ss,ww) 
		- 
		sum(ii in Plants) UpperCap(ii)*nHours*nScenarios*nErrors 
		<= 0;	
	BalMarketPart2(tt):=	!controlling the variable for participation in Bal market to be 1 if any sale variable is > 0
		sum(hh in Hours, ss in Scenarios, ww in Errors) soldBalance(tt,hh,ss,ww) 
		- 
		sum(ii in Plants) UpperCap(ii)*nHours*nScenarios*nErrors 
		<= 0;
	DayAheadMarketPart(tt):=	!controlling the variable for participation in Day ahead market to be 1 if any sale variable is > 0
		sum(hh in Hours, ss in Scenarios) soldDayAhead(tt,hh,ss) 
		- 
		sum(ii in Plants) UpperCap(ii)*nHours*nScenarios 
		<= 0;		
end-do		

writeln("\nModel building completed in ", timestamp - timetracker, " seconds");
writeln("\nSolving model...");
timetracker := timestamp;
		
maximize(NetPresentValue);

writeln("\nModel solved in ", timestamp - timetracker," seconds");

end-model
